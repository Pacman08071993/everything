// Классы в JavaScript были введены в ECMAScript 2015 и представляют собой синтаксический сахар над существующим в JavaScript механизмом прототипного наследования. Синтаксис классов не вводит новую объектно-ориентированную модель, а предоставляет более простой и понятный способ создания объектов и организации наследования.

1)// базовый синтаксис класса :

class MyClass {
  // методы класса
  constructor() { ... }
  method1() { ... }
  method2() { ... }
  method3() { ... }
  ...
}

const myClass = new MyClass(...)

  //Что делает класс?

   *// Создаёт функцию с именем MyClass, которая становится результатом объявления класса. Код функции берётся из метода constructor (она будет пустой, если такого метода нет).

   *// Сохраняет все методы, такие как method1(){...}, в MyClass.prototype

2)//Class - это разновидность функции

3)//Отличия class от обычной функции Коструктора :
    *//Методы класса являются неперечислимыми. Определение класса устанавливает флаг enumerable в false для всех методов в "prototype".
    *//Конструктор класса не может быть вызван без new
    *//Классы всегда используют use strict. Весь код внутри класса автоматически находится в строгом режиме.
    *//Строковое представление конструктора класса в большинстве движков JavaScript начинается с «class …»
    *//Функция, созданная с помощью class, помечена специальным внутренним свойством [[FunctionKind]]:"classConstructor"

4)//Геттеры/сеттеры :

    *// При объявлении класса геттеры/сеттеры создаются на User.prototype, вот так:

          Object.defineProperties(User.prototype, {
            name: {
              get() {
                return this._name
              },
              set(name) {
                // ...
              }
            }
          });




//НАСЛЕДОВАНИЕ КЛАССОВ :

class Animal {
  constructor() {}
  run() {}
  stop() {}
}

class Rabbit extends Animal {
  hide() {}
}

1)//Для того, чтобы наследовать класс от другого, мы должны использовать ключевое слово "extends" и указать название родительского      класса перед {..}.Ключевое слово extends работает, используя прототипы. Оно устанавливает Rabbit.prototype.[[Prototype]] в Animal.prototype.

2)//Переопределение методов - в текущем методе вызываем с помощью 'super' родительский метод super.method().у стрелочных функций нет 'super'

3)//Переопределение конструктора : 

    *//Согласно спецификации, если класс расширяет другой класс и не имеет конструктора, то автоматически создаётся  «пустой» конструктор в котором с помощью super(...args) вызывается родительский класс с аргументами

    *//Когда выполняется обычный конструктор, он создаёт пустой объект и присваивает его this.

    *//Когда запускается конструктор унаследованного класса, он этого не делает. Вместо этого он ждёт, что это сделает конструктор родительского класса.Поэтому, если мы создаём собственный конструктор, мы должны вызвать super, в противном случае объект для this не будет создан, и мы получим ошибку.




//СТАТИЧЕСКИЕ СВОЙТСВА И МЕТОДЫ КЛАССА

//Статический метод - это метод присвоеный самой функции, а не её прототипу(для создания нужно перед методом указать static)

//this статического метода - является сам конструктор класса(объект до точки)

//Статические свойства - выглядят как свойства класса, но с static в начале, тоже самое что MyClass.name = 'Myclass

//Наследование статических свойтст и методов :

    //Дочерняя функция прототипно наследует от функции Родителя.
    //Дочерняя.prototype прототипно наследует от Родителя.prototype.



//ЗАЩИЩЁННЫЕ И ПРИВАТНЫЕ СВОЙТСВА

//Защищённые свойтсва - "_" Это не синтаксис языка: есть хорошо известное соглашение между программистами, что такие свойства и методы не должны быть доступны извне

//Приватные свойства и методы должны начинаться с #. Они доступны только внутри класса.


