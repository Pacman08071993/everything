//Что такое промис?
//1) Promise  – это специальный объект в JavaScript, который связывает «создающий» и «потребляющий» коды вместе. 

let promise = new Promise(function(resolve, reject) {
    // функция-исполнитель (executor)                       //создающий
});

promise
    .then()                                                 //потребляющий 
    .then()
    .catch()



//2) executor - функция исполнитель которaя должна содержать "Создающий код", её аргументы это встроенные два callback "resolve" и "reject". Она запускается автоматически при вызове new Promise

//resolve(value) - когда работа функции executor завершилась с положительным результатом
//reject(error) - когда работа функции executot завершилась с ошибкой (результат обьект ошибки).Вызывать нужно с объектом ошибки


//Сколько состояний есть у промиса?
//3) У promise есть три состояния(State-внутренее, нет доступа) :  

//a)pending - ожидание
//b)fullfilled - выполнено успешно(resolve)
//c)rejected - выполнено с ошибкой(reject)



//4) У промиса есть три варианта результата(result-внутренее, нет доступа)

//a)undefined
//b)value
//c)error


//Сколько результатов может быть у промиса?
//5) В промисе может быть что-то одно, либо результат , либо ошибка



//6) then() - функция потребитель, которая получает либо результат либо ошибку,и возвращает промис(поэтому мы можем сделать цепочку из then)

        promise.then(
            function(result) { /* обработает успешное выполнение */ },
            function(error) { /* обработает ошибку */ }
        );

// У функции then() есть два аргумента которые являются функциями:
            //а) function()-функция выполниться когда промис переходит в состояние выполнен успешно(fullfilled)
            //b) function()-функция выполниться когда проси переходит в состояние выполнен с ошибкой(rejected)



//7) catch() - для обработки ошибок. Если промис завершается с ошибкой то управление переходит в ближайший обработчик catch(), для перехвата ошибки из любого then() в цепочке - нужно установить catch() в конец цепочки



//8) finally() - выполниться когда промис завершиться(он не знает как завершился промис с ошибкой или положительным результатом)







//10) Пробрасывание ошибок - В обычном try..catch мы можем проанализировать ошибку и повторно пробросить дальше, если не можем её обработать. То же самое возможно для промисов.
// Если мы пробросим (throw) ошибку внутри блока .catch, то управление перейдёт к следующему ближайшему обработчику ошибок. А если мы обработаем ошибку и завершим работу обработчика нормально, то продолжит работу ближайший успешный обработчик .then().



//11) Promise API :
        
        //a) Promise.all - принимает массив промисов и возвращает новый промис. Новый промис завершится, когда завершится весь переданный список промисов, и его результатом будет массив их результатов.Порядок элементов массива в точности соответствует порядку исходных промисов.Если любой из промисов завершится с ошибкой, то промис, возвращённый Promise.all, немедленно завершается с этой ошибкой.(возвращает всё или ничего)

        //b) Promise.allSettled всегда ждёт завершения всех промисов. В массиве результатов будет:

            // {status:"fulfilled", value:результат} для успешных завершений,
            // {status:"rejected", reason:ошибка} для ошибок.

        //c) Promise.race - ждёт только первый промис, из которого берёт результат (или ошибку).

        //d)Promise.resolve(value) создаёт успешно выполненный промис с результатом value.

        //e)Promise.reject(error) создаёт промис, завершённый с ошибкой error.


        

//12)microtask - очередь промисов в eventloop :

//       Первым попал - первым вышел
//       Выполнение задачи происходит только в том случае, если ничего больше не запущено.



//13) Async/Await - специальный синтаксис для работы с промисами:
            
    //a)async function() - всегда возвращает промис, значения других типов оборачиваются в завершившийся успешно промис автоматически.
    
    //b)await - можно использовать только внутри async-функций. Заставит интерпретатор JavaScript ждать до тех пор, пока промис справа от await не выполнится. После чего оно вернёт его результат, и выполнение кода продолжится.

    //с) Отлавливать ошибки нужно с помощью try ... catch
            
